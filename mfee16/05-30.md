#### 本日課程目錄
1. [callback][]
2. [promise][]
3. [async & await][]
4. [OOP 摘要][]
5. [一些名詞解釋][]

<br>
<br>

<h3 id="para1">callback</h3>

<br>

callback是一種呼叫函式的方式。

當我們呼叫一個函式時，其實就是在call那個函式。

我們可以在呼叫函式時傳入參數再利用該參數和得到的結果呼叫另一個函式，  
我們也可以在呼叫函式的同時傳入另一個函式並執行他。

像這樣，在呼叫的函示中繼續呼叫另一個函式的行為就稱作**callback**。

<br>

>有些時候，我們可能會為了確保程式間的運行順序而呼叫了一個又一個的callback。  
>乍聽之下這樣的寫作方式沒什麼問題，然而這樣的習慣很容易讓你在無意間寫出過度複雜的回調函式嵌套，見下圖。

<br>

令人聞風喪膽的 **callback hell** (回調地獄)  
![image](https://user-images.githubusercontent.com/79037530/120286892-4e35fd00-c2f1-11eb-9d84-45a55ba170af.png)

這樣的結構不僅難以閱讀，也很容易在修改函式的某一環節時發生錯誤進而導致整個程式癱瘓，正所謂牽一髮而動全身。  

<br>
<br>

<h3 id="para2">promise</h3>

<br>

pormise是一個非同步執行的函式物件。

建立Promise物件時必須傳入一個函式，我們可以為這個函式設置兩個參數resolve和reject，並透過這兩個參數去呼叫Promise內建的函式resolve()和reject()。

resolve()和reject()函式由Promise物件提供，主要功用是用來記錄主函式的運行結果。
resolve負責紀錄成功的結果，reject則負責紀錄失敗的結果。
一般來說，我們會讓resolve和reject紀錄文字訊息，並透過Promise物件提供的方法處理訊息。
然而Promise並沒有限制我們不能在這兩個函式中寫入程式碼。

Promise物件常用的的內建方法有then()和catch()。
then()方法可以接受成功或錯誤訊息，catch方法只能接受錯誤訊息。
然而為了確保可閱讀性，慣例上我們習慣用then()處理成功訊息，用catch()處理錯誤訊息。
Promise的內建方法的主要目的是確保方法()中的程式會在Promise物件運行完畢後執行，就像callback。

Promise物件有3種狀態，分別是
- 擱置（pending）：初始狀態，不是 fulfilled 與 rejected。
- 實現（fulfilled）：表示操作成功地完成。
- 拒絕（rejected）：表示操作失敗了。

執行Javascript程式碼時，Promise物件會被跳過並且被丟到microTask queue進行佇列。
因此我們沒辦法在運行主程式碼的階段中取得Promise物件裡的值。
Promise物件必須在主程式碼運行完畢才會被執行，也因此我們必須利用他提供的內建方法做進一步處理。

我們使用Promise最主要的理由是因為他好閱讀。
我們可以把相互關聯的函式存成一個又一個的Promise物件，並利用promise chain的方式去建立更好閱讀的程式碼。

此外，Promise物件處理錯誤的方法十分聰明且好操作，這也是我們使用Promise物件的主因。



[callback]: https://chengen0612.github.io/mfee16/05-30#para1
[promise]: https://chengen0612.github.io/mfee16/05-30#para2
[async & await]: https://chengen0612.github.io/mfee16/05-30#para3
[OOP 摘要]: https://chengen0612.github.io/mfee16/05-30#para4
[一些名詞解釋]: https://chengen0612.github.io/mfee16/05-30#para5
